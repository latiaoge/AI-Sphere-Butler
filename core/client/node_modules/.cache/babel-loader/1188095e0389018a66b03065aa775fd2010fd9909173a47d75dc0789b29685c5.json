{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useRecorder.js\nimport { useEffect, useRef, useCallback, useState } from 'react';\nexport function useRecorder() {\n  _s();\n  const audioContextRef = useRef(null);\n  const processorRef = useRef(null);\n  const sourceRef = useRef(null);\n  const streamRef = useRef(null);\n  const audioDataRef = useRef({\n    size: 0,\n    buffer: []\n  });\n  const [isRecording, setIsRecording] = useState(false);\n  const [error, setError] = useState(null);\n\n  // 目标输出参数\n  const outputSampleRate = 16000;\n  const sampleBits = 16;\n\n  // 降采样函数\n  const downsampleBuffer = useCallback((buffer, inputRate, outputRate) => {\n    if (outputRate === inputRate) return buffer;\n    const ratio = inputRate / outputRate;\n    const newLength = Math.round(buffer.length / ratio);\n    const result = new Float32Array(newLength);\n    let offsetResult = 0;\n    let offsetBuffer = 0;\n    while (offsetResult < newLength) {\n      let nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);\n      let accum = 0,\n        count = 0;\n      for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n        accum += buffer[i];\n        count++;\n      }\n      result[offsetResult] = accum / count;\n      offsetResult++;\n      offsetBuffer = nextOffsetBuffer;\n    }\n    return result;\n  }, []);\n\n  // PCM编码函数\n  const encodePCM = useCallback(() => {\n    const buffer = audioDataRef.current.buffer;\n    const size = audioDataRef.current.size;\n    let mergedBuffers = new Float32Array(size);\n    let offset = 0;\n    for (let i = 0; i < buffer.length; i++) {\n      mergedBuffers.set(buffer[i], offset);\n      offset += buffer[i].length;\n    }\n    const dataLength = mergedBuffers.length * (sampleBits / 8);\n    const bufferArray = new ArrayBuffer(dataLength);\n    const dataView = new DataView(bufferArray);\n    let dataOffset = 0;\n    for (let i = 0; i < mergedBuffers.length; i++, dataOffset += 2) {\n      let s = Math.max(-1, Math.min(1, mergedBuffers[i]));\n      dataView.setInt16(dataOffset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return new Blob([dataView], {\n      type: 'audio/pcm'\n    });\n  }, [sampleBits]);\n\n  // 清空缓存\n  const clearBuffer = useCallback(() => {\n    audioDataRef.current.buffer = [];\n    audioDataRef.current.size = 0;\n  }, []);\n\n  // 开始录音\n  const start = useCallback(async () => {\n    if (isRecording) return;\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      streamRef.current = stream;\n      const AudioContextClass = window.AudioContext || window.webkitAudioContext;\n      audioContextRef.current = new AudioContextClass();\n      sourceRef.current = audioContextRef.current.createMediaStreamSource(stream);\n\n      // 获取真实采样率\n      const inputSampleRate = audioContextRef.current.sampleRate;\n      processorRef.current = audioContextRef.current.createScriptProcessor(4096, 1, 1);\n      audioDataRef.current.buffer = [];\n      audioDataRef.current.size = 0;\n      processorRef.current.onaudioprocess = e => {\n        const inputData = e.inputBuffer.getChannelData(0);\n        const downsampled = downsampleBuffer(inputData, inputSampleRate, outputSampleRate);\n        audioDataRef.current.buffer.push(downsampled);\n        audioDataRef.current.size += downsampled.length;\n      };\n      sourceRef.current.connect(processorRef.current);\n      processorRef.current.connect(audioContextRef.current.destination);\n      setIsRecording(true);\n      setError(null);\n    } catch (err) {\n      console.error('获取麦克风失败', err);\n      setError(err);\n      throw err;\n    }\n  }, [downsampleBuffer, isRecording]);\n\n  // 停止录音\n  const stop = useCallback(() => {\n    if (!isRecording) return;\n    try {\n      if (processorRef.current) {\n        processorRef.current.disconnect();\n        processorRef.current.onaudioprocess = null;\n        processorRef.current = null;\n      }\n      if (sourceRef.current) {\n        sourceRef.current.disconnect();\n        sourceRef.current = null;\n      }\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(t => t.stop());\n        streamRef.current = null;\n      }\n      if (audioContextRef.current) {\n        audioContextRef.current.close();\n        audioContextRef.current = null;\n      }\n    } catch (e) {\n      console.warn('停止录音时出错', e);\n    } finally {\n      setIsRecording(false);\n    }\n  }, [isRecording]);\n\n  // 组件卸载时自动释放资源的副作用\n  useEffect(() => {\n    return () => {\n      stop();\n    };\n  }, [stop]);\n  return {\n    start,\n    stop,\n    getAudioBlob: encodePCM,\n    clearBuffer,\n    isRecording,\n    error\n  };\n}\n_s(useRecorder, \"yOFpQHLL9nrc4Psfb0Zx9+cvVWw=\");","map":{"version":3,"names":["useEffect","useRef","useCallback","useState","useRecorder","_s","audioContextRef","processorRef","sourceRef","streamRef","audioDataRef","size","buffer","isRecording","setIsRecording","error","setError","outputSampleRate","sampleBits","downsampleBuffer","inputRate","outputRate","ratio","newLength","Math","round","length","result","Float32Array","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","i","encodePCM","current","mergedBuffers","offset","set","dataLength","bufferArray","ArrayBuffer","dataView","DataView","dataOffset","s","max","min","setInt16","Blob","type","clearBuffer","start","stream","navigator","mediaDevices","getUserMedia","audio","AudioContextClass","window","AudioContext","webkitAudioContext","createMediaStreamSource","inputSampleRate","sampleRate","createScriptProcessor","onaudioprocess","e","inputData","inputBuffer","getChannelData","downsampled","push","connect","destination","err","console","stop","disconnect","getTracks","forEach","t","close","warn","getAudioBlob"],"sources":["D:/XM/AI-Sphere-Butler/core/client/src/hooks/useRecorder.js"],"sourcesContent":["// src/hooks/useRecorder.js\r\nimport { useEffect, useRef, useCallback, useState } from 'react';\r\n\r\nexport function useRecorder() {\r\n  const audioContextRef = useRef(null);\r\n  const processorRef = useRef(null);\r\n  const sourceRef = useRef(null);\r\n  const streamRef = useRef(null);\r\n  const audioDataRef = useRef({\r\n    size: 0,\r\n    buffer: [],\r\n  });\r\n\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [error, setError] = useState(null);\r\n\r\n  // 目标输出参数\r\n  const outputSampleRate = 16000;\r\n  const sampleBits = 16;\r\n\r\n  // 降采样函数\r\n  const downsampleBuffer = useCallback((buffer, inputRate, outputRate) => {\r\n    if (outputRate === inputRate) return buffer;\r\n    const ratio = inputRate / outputRate;\r\n    const newLength = Math.round(buffer.length / ratio);\r\n    const result = new Float32Array(newLength);\r\n    let offsetResult = 0;\r\n    let offsetBuffer = 0;\r\n    while (offsetResult < newLength) {\r\n      let nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);\r\n      let accum = 0,\r\n        count = 0;\r\n      for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\r\n        accum += buffer[i];\r\n        count++;\r\n      }\r\n      result[offsetResult] = accum / count;\r\n      offsetResult++;\r\n      offsetBuffer = nextOffsetBuffer;\r\n    }\r\n    return result;\r\n  }, []);\r\n\r\n  // PCM编码函数\r\n  const encodePCM = useCallback(() => {\r\n    const buffer = audioDataRef.current.buffer;\r\n    const size = audioDataRef.current.size;\r\n    let mergedBuffers = new Float32Array(size);\r\n    let offset = 0;\r\n    for (let i = 0; i < buffer.length; i++) {\r\n      mergedBuffers.set(buffer[i], offset);\r\n      offset += buffer[i].length;\r\n    }\r\n    const dataLength = mergedBuffers.length * (sampleBits / 8);\r\n    const bufferArray = new ArrayBuffer(dataLength);\r\n    const dataView = new DataView(bufferArray);\r\n    let dataOffset = 0;\r\n    for (let i = 0; i < mergedBuffers.length; i++, dataOffset += 2) {\r\n      let s = Math.max(-1, Math.min(1, mergedBuffers[i]));\r\n      dataView.setInt16(dataOffset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\r\n    }\r\n    return new Blob([dataView], { type: 'audio/pcm' });\r\n  }, [sampleBits]);\r\n\r\n  // 清空缓存\r\n  const clearBuffer = useCallback(() => {\r\n    audioDataRef.current.buffer = [];\r\n    audioDataRef.current.size = 0;\r\n  }, []);\r\n\r\n  // 开始录音\r\n  const start = useCallback(async () => {\r\n    if (isRecording) return;\r\n\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      streamRef.current = stream;\r\n\r\n      const AudioContextClass = window.AudioContext || window.webkitAudioContext;\r\n      audioContextRef.current = new AudioContextClass();\r\n\r\n      sourceRef.current = audioContextRef.current.createMediaStreamSource(stream);\r\n\r\n      // 获取真实采样率\r\n      const inputSampleRate = audioContextRef.current.sampleRate;\r\n\r\n      processorRef.current = audioContextRef.current.createScriptProcessor(4096, 1, 1);\r\n\r\n      audioDataRef.current.buffer = [];\r\n      audioDataRef.current.size = 0;\r\n\r\n      processorRef.current.onaudioprocess = (e) => {\r\n        const inputData = e.inputBuffer.getChannelData(0);\r\n        const downsampled = downsampleBuffer(inputData, inputSampleRate, outputSampleRate);\r\n        audioDataRef.current.buffer.push(downsampled);\r\n        audioDataRef.current.size += downsampled.length;\r\n      };\r\n\r\n      sourceRef.current.connect(processorRef.current);\r\n      processorRef.current.connect(audioContextRef.current.destination);\r\n\r\n      setIsRecording(true);\r\n      setError(null);\r\n    } catch (err) {\r\n      console.error('获取麦克风失败', err);\r\n      setError(err);\r\n      throw err;\r\n    }\r\n  }, [downsampleBuffer, isRecording]);\r\n\r\n  // 停止录音\r\n  const stop = useCallback(() => {\r\n    if (!isRecording) return;\r\n\r\n    try {\r\n      if (processorRef.current) {\r\n        processorRef.current.disconnect();\r\n        processorRef.current.onaudioprocess = null;\r\n        processorRef.current = null;\r\n      }\r\n      if (sourceRef.current) {\r\n        sourceRef.current.disconnect();\r\n        sourceRef.current = null;\r\n      }\r\n      if (streamRef.current) {\r\n        streamRef.current.getTracks().forEach((t) => t.stop());\r\n        streamRef.current = null;\r\n      }\r\n      if (audioContextRef.current) {\r\n        audioContextRef.current.close();\r\n        audioContextRef.current = null;\r\n      }\r\n    } catch (e) {\r\n      console.warn('停止录音时出错', e);\r\n    } finally {\r\n      setIsRecording(false);\r\n    }\r\n  }, [isRecording]);\r\n\r\n  // 组件卸载时自动释放资源的副作用\r\n  useEffect(() => {\r\n    return () => {\r\n      stop();\r\n    };\r\n  }, [stop]);\r\n\r\n  return {\r\n    start,\r\n    stop,\r\n    getAudioBlob: encodePCM,\r\n    clearBuffer,\r\n    isRecording,\r\n    error,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}